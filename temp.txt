import parquetjs from 'npm:@dsnp/parquetjs';
import { findMean, findStDev, isValueInRange, handleAlert } from './helpers.ts';
import { RawRecord, SensorLog } from './types.ts';


let reader = await parquetjs.ParquetReader.openFile('../lab.parquet');

// only read columns we care about
let cursor = reader.getCursor(['time', 'TagName', 'max']);

// CONSTANTS
const THRESHOLD_ST_DEV = 3;
const OUTLIERS_PER_HOUR_TRIGGER = 5;
const NANO_PER_HOUR = 3600000000000;

// will hold records relating to air supply. Grouped by sensor
// with value as an of array of objects with time and value
const airSupplyRecords: SensorLog = {};

// loop through dataset
let record: RawRecord | null = null;
while (record = await cursor.next()) {

	// only store air supply data that's not null
	if (record.TagName.endsWith('.SAT') && record.max && record.time) {

		// check if value belongs to an existing sensor. 
		// Either create new entry or push sensor data to array
		const newTempRecord = { time: record.time, value: record.max }
		if (Object.keys(airSupplyRecords).includes(record.TagName)) {
			airSupplyRecords[record.TagName].values.push(newTempRecord);
		} else {
			airSupplyRecords[record.TagName] = { values: [newTempRecord] };
		}
	}
}

// sort values by their timestamps and calculate mean & st. dev.
for (const [sensor, sensorData] of Object.entries(airSupplyRecords)) {

	let mean = findMean(sensorData.values);
	let stDev = findStDev(sensorData.values, mean);

	// only keep out-of-range values
	let tempSensorData = sensorData.values.filter(elem => !isValueInRange(elem.value, mean, stDev, THRESHOLD_ST_DEV))

	tempSensorData.sort((a, b) => {
		return a.time > b.time ? 1 : -1;
	});
	sensorData.values = tempSensorData;
}

for (const [sensor, sensorData] of Object.entries(airSupplyRecords)) {
	// get timestamps only, since data is guarenteed to be outliers only and sorted.
	let timeStamps = sensorData.values.map(elem => elem.time);

	if(timeStamps.length < 5) continue; // if there are fewer than 5 total outliers, quit iteration

	// find sequences of timestamps where five or more occur in a one hour span
	let start = 0;
	let end = 4;

	let sequences = []

	let temp_start = '';
	let temp_end = '';

	while(end < timeStamps.length) {
		if(timeStamps[end] - timeStamps[start] <= NANO_PER_HOUR) {
			// still within 1 hour
			if(end - start === 5) {
				temp_start = new Date(parseInt(timeStamps[start]) / 1000000).toString()
			}
			end++;
		} else {
			// >1 hour elapsed.
			if (end - start >= 5) {
				temp_end = new Date(parseInt(timeStamps[end - 1]) / 1000000).toString()
				sequences.push({ start: temp_start, end: temp_end })
				temp_start = '';
				temp_end = '';
				start = end;
				end++;
			} else {
				start++;
			}
		}
	}
	console.log(JSON.stringify(sequences))
}



	// while(sensorData.values[ptr2].time - sensorData.values[ptr1].time < NANO_PER_HOUR) {
	// 	ptr2++;
	// 	if(sensorData.values[ptr2].time - sensorData.values[ptr1].time >= NANO_PER_HOUR) {
	// 		// we hit the end of the window with too few hits. Increase ptr1
	// 		ptr1++;
	// 	} else {
	// 		// we hit the end without any hits
	// 	}
	// }





// 	let ptr = 0;
// 	let beginSequence = 0; // tracks beginning of error sequence
// 	while (ptr < sensorData.values.length - OUTLIERS_PER_HOUR_TRIGGER) {

// 		let timeStamp = sensorData.values[ptr].time;
// 		let value = sensorData.values[ptr].value;

// 		// if current value is not an error, reset everything
// 		if (isValueInRange(value, mean, stDev, THRESHOLD_ST_DEV)) {
// 			// check if we just ended an error streak
// 			if (ptr - beginSequence >= 5) {
// 				handleAlert(sensorData.values, sensor, beginSequence, ptr, mean, stDev);
// 			}
// 			ptr++;
// 			beginSequence = ptr;
// 		} else {
// 			// we're looking at an error.
// 			// if this is the first instance, set the beginning sequence index
// 			if (beginSequence >= ptr) {
// 				// beginnning
// 				beginSequence = ptr;
// 				ptr++;
// 			} else {
// 				// in the middle
// 				if (timeStamp - sensorData.values[beginSequence].time >= NANO_PER_HOUR) {
// 					beginSequence++;
// 				}
// 				ptr++;
// 			}
// 		}
// 	}
// }